AWSTemplateFormatVersion: '2010-09-09'
Description: >
  Germain CAIJO - Exercice 1
    - Creation d'un bucket S3 fixe : my-bigdata-bucket-fr-paris
    - Creation d'une table DynamoDB fixe : BigDataTable
    - Lancement d'une instance EC2 t3.micro (Amazon Linux 2023)
    - Creation d'un rôle IAM avec droits S3 et DynamoDB
    - Ajout d'un UserData qui :
    - Écriture d'un fichier dans S3
    - Ajout d'un enregistrement dans DynamoDB

Parameters:
  # Sert à se connecter à l’instance en SSH
  EC2KeyName:
    Type: AWS::EC2::KeyPair::KeyName
    Description: Name of an existing EC2 KeyPair
    
  LatestAmiId:
    Type: AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>
    Default: /aws/service/ami-amazon-linux-latest/al2023-ami-kernel-default-x86_64
    Description: Latest Amazon Linux 2023 AMI

Resources:

  # S3 Bucket : pour stocker les fichiers 
  # Nom fixé pour simplifier le déploiement
  S3Bucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub "my-bigdata-bucket-${AWS::StackName}-${AWS::Region}"

  # DynamoDB TablecNoSQL pour stocker des événements, métadonnées, résultats de traitements
  DynamoTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub "BigDataTable-${AWS::StackName}"
      AttributeDefinitions:
        - AttributeName: pk   # Partition Key (clé primaire)
          AttributeType: S
        - AttributeName: sk   # Sort Key (clé de tri)
          AttributeType: S
      KeySchema:
        - AttributeName: pk
          KeyType: HASH
        - AttributeName: sk
          KeyType: RANGE
      BillingMode: PAY_PER_REQUEST  # Pas besoin de gérer la capacité, facturation à l’usage

  # IAM Role pour EC2 pour autoriser l’instance EC2 à accéder à S3 et DynamoDB
  EC2Role:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: [ec2.amazonaws.com]
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonS3FullAccess
        - arn:aws:iam::aws:policy/AmazonDynamoDBFullAccess

  # Profil d’instance nécessaire pour associer le rôle à EC2
  EC2InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Roles: [!Ref EC2Role]

  # -------------------------------
  # Security Group
  # -------------------------------
  # Permet l’accès SSH (port 22) à l’instance EC2
  InstanceSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Enable SSH access
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 22
          ToPort: 22
          CidrIp: 0.0.0.0/0

  # -------------------------------
  # Instance EC2 : serveur virtuel dans le cloud
  # -------------------------------
  # - petit modèle 't3.micro' pour les tests, 
  #   * avec la clé 'EC2KeyName' pour se connecter
  #   * le pare-feu 'securityGroup' créé
  #   * les permissions IAM 'EC2InstanceProfile'
  #   * le système d'exploitation 'ImageID'
  # - UserData :
  #   * mise à jour du système
  #   * installe quelques outils (cloudwatch, jq)
  #   * écrit un fichier test "hello.txt" dans S3 
  #   * enregistre une ligne de test dans DynamoDB
  EC2Instance:
    Type: AWS::EC2::Instance
    Properties:
      InstanceType: t3.micro
      KeyName: !Ref EC2KeyName
      SecurityGroupIds: [!GetAtt InstanceSecurityGroup.GroupId]
      IamInstanceProfile: !Ref EC2InstanceProfile
      ImageId: !Ref LatestAmiId
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash
          set -eux
          dnf update -y
          dnf install -y amazon-cloudwatch-agent jq
          echo "hello from $(hostname)" > /tmp/hello.txt
          aws s3 cp /tmp/hello.txt s3://${S3Bucket}/hello.txt || true
          INSTANCE_ID=$(curl -s http://169.254.169.254/latest/meta-data/instance-id)
          TIMESTAMP=$(date +%s)
          aws dynamodb put-item --table-name ${DynamoTable} \
            --item '{"pk":{"S":"host#'"$INSTANCE_ID"'"},"sk":{"S":"hello#'"$TIMESTAMP"'"},"msg":{"S":"hello from EC2"}}' || true

  # Rôle IAM pour Lambda (contrôle EC2)
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: LambdaEC2Control
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - ec2:StartInstances
                  - ec2:StopInstances
                Resource: !Sub arn:aws:ec2:${AWS::Region}:${AWS::AccountId}:instance/${EC2Instance}
              - Effect: Allow
                Action:
                  - ec2:StartInstances
                  - ec2:StopInstances
                Resource: !Sub arn:aws:ec2:${AWS::Region}:${AWS::AccountId}:instance/${EC2Instance}
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: "*"

   # Lambda pour start/stop EC2
  EC2SchedulerLambda:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.11
      Handler: index.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 30
      Environment:
        Variables:
          INSTANCE_ID: !Ref EC2Instance
      Code:
        ZipFile: |
          import boto3
          import os

          ec2 = boto3.client("ec2")
          INSTANCE_ID = os.environ.get("INSTANCE_ID")

          def lambda_handler(event, context):
              action = event.get("action", "").lower()
              if not INSTANCE_ID:
                  return {"status": "error", "message": "No INSTANCE_ID"}
              if action == "stop":
                  ec2.stop_instances(InstanceIds=[INSTANCE_ID])
                  return {"status": "success", "message": f"Instance {INSTANCE_ID} stopped"}
              elif action == "start":
                  ec2.start_instances(InstanceIds=[INSTANCE_ID])
                  return {"status": "success", "message": f"Instance {INSTANCE_ID} started"}
              else:
                  return {"status": "error", "message": "Invalid action"}

  # EventBridge Rules
  StopRule:
    Type: AWS::Events::Rule
    Properties:
      ScheduleExpression: cron(0 22 * * ? *)
      Targets:
        - Arn: !GetAtt EC2SchedulerLambda.Arn
          Id: StopTarget
          Input: '{"action": "stop"}'

  StartRule:
    Type: AWS::Events::Rule
    Properties:
      ScheduleExpression: cron(0 5 * * ? *)
      Targets:
        - Arn: !GetAtt EC2SchedulerLambda.Arn
          Id: StartTarget
          Input: '{"action": "start"}'

  LambdaPermissionStop:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref EC2SchedulerLambda
      Principal: events.amazonaws.com
      SourceArn: !GetAtt StopRule.Arn

  LambdaPermissionStart:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref EC2SchedulerLambda
      Principal: events.amazonaws.com
      SourceArn: !GetAtt StartRule.Arn

Outputs:
  EC2InstanceId:
    Value: !Ref EC2Instance
  LambdaName:
    Value: !Ref EC2SchedulerLambda
  S3BucketName:
    Value: !Ref S3Bucket
  DynamoTableName:
    Value: !Ref DynamoTable
